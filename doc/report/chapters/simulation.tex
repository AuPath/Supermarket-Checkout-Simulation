\chapter{Simulazione e analisi dei risultati}
\label{chapter:simulation}

In questo capitolo vedremo i risultati delle simulazioni eseguite sul nostro modello. Introdurremo due misure che ci aiuteranno a disegnare dei grafici per mettere a confronto simulazioni fatte con strategie di scelta della coda diverse e anche con parametri diversi.

\vspace*{1\baselineskip}

\todo{per ognuna di queste simulazioni fare i grafici: grafico fondamentale (flusso asse y, densità asse x), tempo totale di simulazione, tempo medio d'attesa dei clienti (fare grafico con media e deviazione standard, i dati sono nel datacollector), grafico KDE (Kernel density estimates - ovvero densità sull'asse y e waiting time sull'asse x), grafico con tempo sull'asse x e sull'asse y probabilità di stare meno di 5 minuti in coda per ogni strategia (vedi articolo polacchi per questi ultimi due grafici)}

Al fine di analizzare i risultati sono state introdotte le definizioni di densità e flusso di clienti per ogni step di simulazione; queste misure ci permettono di misurare l'affluenza dei clienti nel supermercato e come questa viene gestita dalle casse che hanno il potere di attivarsi o disattivarsi in base alla quantità di clienti presenti. Densità e flusso permetteranno di disegnare i grafici fondamentali che mostrano per ogni simulazione come le casse smaltiscono l'afflusso di clienti in entrata, soprattutto nei periodi critici (in cui il supermercato raggiunge una quantità di clienti che "mettono alla prova" le casse).

La \textbf{densità} di clienti per step corrisponde al numero di clienti medio per ogni cassa; la densità allo step $i$ è:
\begin{equation}
	\text{density}_i = \frac{\# \text{ customers in the supermarket}}{\# \text{ cashdesks}}
\end{equation}
Si terrà conto della densità totale, della densità per le casse standard o self-service e della densità per le casse self-scan.

Il \textbf{flusso in entrata} di clienti per step corrisponde al numero di clienti che entrano ad ogni step per ogni cassa in media; il flusso allo step $i$ è:
\begin{equation}
	\text{flow}_i = \frac{\# \text{ customers entering in the supermarket}}{\# \text{ cashdesks}}
\end{equation}
Si terrà conto del flusso totale, del flusso per le casse standard o self-service e del flusso per le casse self-scan.

\section{Simulazione allo scopo di validazione}

\paragraph{Stato dell'arte}

Al fine di validare il modello, come primo esperimento è stata condotta una simulazione con gli stessi parametri usati nell'articolo \cite{article1}. In quella simulazione il supermercato contiene 20 casse standard e 6 casse self-service; si noti che nel lavoro citato, le casse si attivano o disattivano in base ai dati raccolti dai ricercatori nei supermercati, nel nostro modello invece le casse si attivano in base al numero di clienti presenti nel supermercato, in base a un parametro che è possibile cambiare nel momento in cui si raccolgono i dati. Vengono messe a confronto le strategie diverse di scelta della coda da parte dei clienti, arrivando alla conclusione che la strategia che porta al minor tempo d'attesa è quella chiamata "minimo tempo d'attesa in base alla \textit{power regression}" nel capitolo \ref{implementation:intro}; tuttavia i risultati portano a dire che questo scenario non è quello ottimale per tutti i supermercati negli orari di punta.

Nelle prossime simulazioni verrà testato il jockeying, in particolare si metteranno a confronto le diverse strategie di scelta della coda e di jockeying per stabilire se questo porti a un miglioramento dell'esperienza del cliente nel supermercato. Questi esperimenti verranno poi messi a confronto con una simulazione in cui c'è soltanto la coda condivisa per le casse standard, pertanto i clienti non avranno bisogno di scegliere la coda nè di fare jockeying: in base a quanto detto nell'articolo \cite{yanagisawa2011methods}, questo tipo di coda dovrebbe portare a tempi di attesa minori. 
Verranno quindi introdotte nella simulazione le casse self-scan con rilettura randomica, si prevede che queste portino a una diminuzione considerevole dei tempi d'attesa in coda, in quanto viene a mancare la fase di scanner da parte dei cassieri. Infine verrà effettuata una simulazione con gli elementi probabilistici già descritti nel corso dei capitoli \ref{chapter:model} e \ref{implementation:intro}, che rendono l'esperimento non deterministico e a nostro riguardo più realistico.

\paragraph{Simulazione con gli stessi parametri}

Parametri:
entering zone e shopping zone sempre uguali
no strategy di jockeying
20 casse normali
6 casse self service
0 self-scan
0 probabilità cliente self-scan
0 deviazione standard per stima del basket size da parte del cliente
no coda condivisa

Strategie diverse di scelta della coda:
\begin{enumerate}
	\item Minimo numero di elementi: dati \textit{validazione1}
	\item Minimo numero di persone: dati \textit{validazione2}
	\item Minimo tempo d'attesa in base al tempo di servizio medio: dati \textit{validazione3}
	\item Minimo tempo d'attesa in base alle power regression: dati \textit{validazione4} 
\end{enumerate}

\section{Simulazione con strategie \textit{jockey}}

Parametri:
entering zone e shopping zone sempre uguali
20 casse normali
6 casse self service
0 self-scan
0 probabilità cliente self-scan
0 deviazione standard per stima del basket size da parte del cliente
no coda condivisa

Strategie diverse di scelta della coda:
\begin{enumerate}
	\item Minimo numero di elementi:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{coda1jockey1}
		\item Minimo numero di persone: dati \textit{coda1jockey2}
	\end{enumerate}
	\item Minimo numero di persone:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{coda2jockey1}
		\item Minimo numero di persone: dati \textit{coda2jockey2}
	\end{enumerate}
	\item Minimo tempo d'attesa in base al tempo di servizio medio:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{coda3jockey1}
		\item Minimo numero di persone: dati \textit{coda3jockey2}
	\end{enumerate}
	\item Minimo tempo d'attesa in base alle power regression: Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{coda4jockey1}
		\item Minimo numero di persone: dati \textit{coda4jockey2}
	\end{enumerate}
\end{enumerate}

\section{Simulazione con coda condivisa}

Parametri:
entering zone e shopping zone sempre uguali
20 casse normali
6 casse self service
0 self-scan
0 probabilità cliente self-scan
0 deviazione standard per stima del basket size da parte del cliente
sì coda condivisa
\\
dati \textit{codacondivisa}

\section{Simulazione con casse self-scan}

Parametri:
entering zone e shopping zone sempre uguali
0 casse normali
0 casse self service
n self-scan
1 probabilità cliente self-scan
0 deviazione standard per stima del basket size da parte del cliente
no coda condivisa
\\
dati \textit{self-scan}

\section{Simulazione non deterministica}

Parametri:
entering zone e shopping zone sempre uguali
20 casse normali
6 casse self service
n self-scan
0.5 probabilità cliente self-scan
0.1 deviazione standard per stima del basket size da parte del cliente
no coda condivisa

Strategie diverse di scelta della coda:
\begin{enumerate}
	\item Minimo numero di elementi:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{prob-coda1jockey1}
		\item Minimo numero di persone: dati \textit{prob-coda1jockey2}
	\end{enumerate}
	\item Minimo numero di persone:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{prob-coda2jockey1}
		\item Minimo numero di persone: dati \textit{prob-coda2jockey2}
	\end{enumerate}
	\item Minimo tempo d'attesa in base al tempo di servizio medio:
	Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{prob-coda3jockey1}
		\item Minimo numero di persone: dati \textit{prob-coda3jockey2}
	\end{enumerate}
	\item Minimo tempo d'attesa in base alle power regression: Strategie diverse di jockey:
	\begin{enumerate}
		\item Minimo numero di elementi: dati \textit{prob-coda4jockey1}
		\item Minimo numero di persone: dati \textit{prob-coda4jockey2}
	\end{enumerate}
\end{enumerate}

\vspace*{1\baselineskip}


\todo{In questo capitolo dove necessario citare xu1996dynamic che dice
  che a parità di parametri un sistema con jockeying è più efficente
  che uno senza}

Abbiamo visto che ... nel prossimo capitolo tiriamo le conclusioni.
